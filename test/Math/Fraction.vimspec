Describe Math.Fraction
  Before all
    let F = vital#vital#new().import('Math.Fraction')
    let assert = themis#helper('assert')
  End

  Describe .new() basic
    It generate arg count 0
      let r = F.new()
      Assert NotEquals(r, v:none)
    End
    It generate arg count 1
      let r = F.new(1)
      Assert NotEquals(r, v:none)
    End
    It generate arg count 2
      let r = F.new(1, 2)
      Assert NotEquals(r, v:none)
    End
  End

  Describe .to_string() basic
    It value 0
      let r = F.new()
      Assert Equals(F.to_string(r), '0')
    End
    It value 1
      let r = F.new(1)
      Assert Equals(F.to_string(r), '1')
    End
    It value 1/2
      let r = F.new(1, 2)
      Assert Equals(F.to_string(r), '1/2')
    End
  End

  Describe .new() and .to_string() complex
    It generate arg count 1 value as negative
      let r = F.new(-2)
      Assert Equals(F.to_string(r), '-2')
    End
    It value numerator negative
      let r = F.new(-1, 2)
      Assert Equals(F.to_string(r), '-1/2')
    End
    It value denominator negative
      let r = F.new(1, -2)
      Assert Equals(F.to_string(r), '-1/2')
    End
    It value numerator,denominator both negative
      let r = F.new(-1, -2)
      Assert Equals(F.to_string(r), '1/2')
    End
    It rational non reciprocal
      let r = F.new(6, 8)
      Assert Equals(F.to_string(r), '3/4')
    End
    It numerator greater than denominator
      let r = F.new(8, 6)
      Assert Equals(F.to_string(r), '4/3')
    End
    " Assertion test need
  End

  Describe .from_string()
    It generate arg count 0
      let r = F.new()
      Assert Equals(F.to_string(r), '0')
    End
    It generate arg count 1
      let r = F.new(1)
      Assert Equals(F.to_string(r), '1')
    End
    It generate arg count 2
      let r = F.new(1, 2)
      Assert Equals(F.to_string(r), '1/2')
    End
  End
End
